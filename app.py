import os
import json
import uuid
import shutil
import datetime
import re
import subprocess
import time
import sys
import signal
import ast
import traceback
import requests
import tempfile # <--- NEW: SAFER LOGGING
from flask import Flask, render_template, request, jsonify, send_file, Response
from werkzeug.utils import secure_filename
from google import genai
from google.genai import types
from dotenv import load_dotenv

# --- FORCE LOAD .ENV ---
BASE_DIR = os.path.dirname(os.path.abspath(__file__))
env_path = os.path.join(BASE_DIR, '.env')
load_dotenv(env_path)

app = Flask(__name__)

# --- GLOBAL STATE ---
current_user_process = None 

# --- CONFIGURATION ---
PROJECTS_DIR = os.path.join(BASE_DIR, "projects")
BACKUP_DIR = os.path.join(BASE_DIR, "backups")
UPLOAD_FOLDER = os.path.join(BASE_DIR, "static", "uploads")
USER_APP_PORT = 5005

os.makedirs(PROJECTS_DIR, exist_ok=True)
os.makedirs(BACKUP_DIR, exist_ok=True)
os.makedirs(UPLOAD_FOLDER, exist_ok=True)
app.config['UPLOAD_FOLDER'] = UPLOAD_FOLDER

# API KEY DEBUG
GENAI_API_KEY = os.getenv("GEMINI_API_KEY")
if not GENAI_API_KEY:
    print(f"‚ùå CRITICAL ERROR: API Key is missing!")
else:
    print(f"‚úÖ API Key found.")

client = genai.Client(api_key=GENAI_API_KEY) if GENAI_API_KEY else None

# --- HELPER FUNCTIONS ---

def get_project_dir(name):
    clean_name = secure_filename(name)
    if not clean_name: return None
    path = os.path.join(PROJECTS_DIR, clean_name)
    if not os.path.exists(path):
        os.makedirs(os.path.join(path, "templates"), exist_ok=True)
    return path

def create_backup(project_name, label="AutoSave"):
    src = get_project_dir(project_name)
    if not src or not os.path.exists(src): return
    timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
    backup_folder = os.path.join(BACKUP_DIR, secure_filename(project_name))
    os.makedirs(backup_folder, exist_ok=True)
    zip_name = f"{timestamp}__{secure_filename(label)}"
    shutil.make_archive(os.path.join(backup_folder, zip_name), 'zip', src)

def ensure_aux_files(project_path, project_name):
    try:
        req_path = os.path.join(project_path, "requirements.txt")
        if not os.path.exists(req_path):
            with open(req_path, "w") as f: f.write("flask\npython-dotenv\n")
        readme_path = os.path.join(project_path, "README.md")
        if not os.path.exists(readme_path):
            with open(readme_path, "w") as f:
                f.write(f"# {project_name}\n\nGenerated by AI Builder.")
    except Exception as e:
        print(f"Aux File Error: {e}")

def extract_json_from_text(text):
    try:
        start = text.find('{')
        end = text.rfind('}') + 1
        if start == -1 or end == 0:
            return text.replace("```json", "").replace("```", "").strip()
        return text[start:end]
    except:
        return text

def kill_process_on_port(port):
    """Safely tries to kill old processes, ignores errors on Azure."""
    try:
        subprocess.run(["pkill", "-f", f"port={port}"], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        try:
            result = subprocess.check_output(f"lsof -t -i:{port}", shell=True, stderr=subprocess.DEVNULL)
            pids = result.decode().strip().split('\n')
            for pid in pids:
                if pid: os.kill(int(pid), signal.SIGKILL)
        except: pass 
    except Exception as e:
        print(f"‚ö†Ô∏è Cleanup warning: {e}")

def cleanup_old_backups(project_name):
    backup_folder = os.path.join(BACKUP_DIR, secure_filename(project_name))
    if not os.path.exists(backup_folder): return
    now = datetime.datetime.now()
    two_weeks_ago = now - datetime.timedelta(weeks=2)
    for f in os.listdir(backup_folder):
        if f.endswith('.zip') and "_STARRED" not in f:
            try:
                ts_str = f.split('__')[0]
                file_time = datetime.datetime.strptime(ts_str, "%Y%m%d_%H%M%S")
                if file_time < two_weeks_ago: os.remove(os.path.join(backup_folder, f))
            except: pass

# --- ROUTES ---

@app.route('/')
def index(): return render_template('builder.html')

@app.route('/projects')
def list_projects():
    projects = [d for d in os.listdir(PROJECTS_DIR) if os.path.isdir(os.path.join(PROJECTS_DIR, d))]
    return jsonify({"projects": sorted(projects)})

@app.route('/create_project', methods=['POST'])
def create_project():
    try:
        name = request.json.get('name')
        if not name: return jsonify({"success": False, "error": "No name provided"})
        path = get_project_dir(name)
        ensure_aux_files(path, name)
        if os.path.exists(os.path.join(path, "templates", "index.html")): return jsonify({"success": True, "name": name})
        
        with open(os.path.join(path, "app.py"), "w") as f:
            f.write(f"import os\nfrom flask import Flask, render_template\napp = Flask(__name__)\n@app.route('/')\ndef home(): return render_template('index.html')\nif __name__ == '__main__':\n    port = int(os.environ.get('PORT', {USER_APP_PORT}))\n    app.run(debug=True, host='0.0.0.0', port=port)")
        with open(os.path.join(path, "templates", "index.html"), "w") as f:
            f.write(f"<h1>{name}</h1><p>Ready.</p>")
        return jsonify({"success": True, "name": name})
    except Exception as e: return jsonify({"success": False, "error": str(e)})

@app.route('/delete_project', methods=['POST'])
def delete_project():
    try:
        name = request.json.get('name')
        
        # 1. CRITICAL: Stop the app first to release file locks
        # If we don't do this, Windows/Azure blocks the deletion
        global current_user_process
        if current_user_process:
            try: 
                os.kill(current_user_process.pid, signal.SIGTERM)
                current_user_process.wait(timeout=1)
            except: pass
        kill_process_on_port(USER_APP_PORT)
        
        # 2. Now safe to delete
        path = get_project_dir(name)
        if path and os.path.exists(path):
            # Create a "Graveyard" backup just in case
            create_backup(name, "Pre_Delete")
            shutil.rmtree(path)
            return jsonify({"success": True})
            
        return jsonify({"success": False, "error": "Project not found"})
    except Exception as e:
        return jsonify({"success": False, "error": str(e)})
@app.route('/get_file', methods=['POST'])
def get_file():
    try:
        data = request.json; base = get_project_dir(data.get('project')); filename = data.get('filename', 'index.html')
        path = os.path.join(base, 'app.py') if filename == 'app.py' else os.path.join(base, 'templates', filename)
        if os.path.exists(path):
            with open(path, "r", encoding="utf-8") as f: return jsonify({"code": f.read()})
        return jsonify({"code": ""})
    except: return jsonify({"code": "Error reading file"})

@app.route('/save_file', methods=['POST'])
def save_file():
    try:
        data = request.json; base = get_project_dir(data.get('project')); filename = data.get('filename')
        path = os.path.join(base, 'app.py') if filename == 'app.py' else os.path.join(base, 'templates', filename)
        create_backup(data.get('project'), f"Manual_Save_{filename}")
        with open(path, "w", encoding="utf-8") as f: f.write(data.get('code'))
        return jsonify({"success": True})
    except Exception as e: return jsonify({"success": False, "error": str(e)})

# --- GENERATE AI (WITH ROBUST JSON FIX) ---
@app.route('/generate', methods=['POST'])
def generate():
    if not client: return jsonify({"success": False, "error": "No API Key"})
    try:
        data = request.json
        project = data.get('project')
        prompt = data.get('prompt')
        print(f"üöÄ Generating for {project}: {prompt}")
        
        base_dir = get_project_dir(project)
        app_path = os.path.join(base_dir, 'app.py')
        templates_dir = os.path.join(base_dir, 'templates')
        static_dir = os.path.join(base_dir, 'static')
        
        # 1. READ ALL FILES FOR CONTEXT
        context_str = ""
        if os.path.exists(app_path): context_str += f"\n--- app.py ---\n{open(app_path, 'r', encoding='utf-8').read()}\n"
        if os.path.exists(templates_dir):
            for f in sorted(os.listdir(templates_dir)):
                if f.endswith('.html'): context_str += f"\n--- templates/{f} ---\n{open(os.path.join(templates_dir, f), 'r', encoding='utf-8').read()}\n"
        if os.path.exists(static_dir):
            for f in sorted(os.listdir(static_dir)):
                if f.endswith('.css'): context_str += f"\n--- static/{f} ---\n{open(os.path.join(static_dir, f), 'r', encoding='utf-8').read()}\n"
        
        create_backup(project, "AI_Update")

        sys_instr = f"""
        You are an expert Full Stack Python Developer.
        User Request: "{prompt}"
        === CURRENT PROJECT FILES ===
        {context_str}
        =============================
        CRITICAL RULES:
        1. Return VALID JSON with keys: "app_code", "html_code".
        2. "app_code" must be the full Python string.
        3. "html_code" MUST be a JSON Dictionary where keys are filenames (e.g., 'templates/index.html', 'static/style.css') and values are the file content.
        4. If editing ONE file, you MUST return the others unchanged in the dictionary.
        5. app.py MUST have imports and: port = int(os.environ.get('PORT', {USER_APP_PORT}))
        """
        
        tools = [types.Tool(google_search=types.GoogleSearch())] if data.get('use_news') else []
        response = client.models.generate_content(
            model='gemini-2.5-flash',
            contents=sys_instr,
            config=types.GenerateContentConfig(tools=tools, response_mime_type="application/json")
        )
        
        # --- ROBUST PARSING BLOCK ---
        raw_text = extract_json_from_text(response.text)
        try:
            result = json.loads(raw_text)
        except json.JSONDecodeError:
            print("‚ö†Ô∏è JSON Error detected. Attempting to sanitize...")
            try:
                sanitized = re.sub(r'\\(?![/u"\\bfnrt])', r'\\\\', raw_text)
                result = json.loads(sanitized)
            except:
                fixed_for_ast = raw_text.replace("null", "None").replace("true", "True").replace("false", "False")
                result = ast.literal_eval(fixed_for_ast)
        # ---------------------------
        
        # 1. Save Python App
        new_app = str(result.get('app_code', '')).strip()
        if len(new_app) > 20:
            with open(app_path, "w", encoding="utf-8") as f: f.write(new_app)

        # 2. Save HTML/CSS
        raw_html = result.get('html_code')
        if isinstance(raw_html, str) and raw_html.strip().startswith('{'):
            try: raw_html = ast.literal_eval(raw_html)
            except: pass

        if isinstance(raw_html, dict):
            for fname, content in raw_html.items():
                fname = fname.replace('\\', '/')
                if fname == 'style.css': fname = 'static/style.css'
                if not '/' in fname and fname.endswith('.html'): fname = f"templates/{fname}"
                full_path = os.path.join(base_dir, fname)
                os.makedirs(os.path.dirname(full_path), exist_ok=True)
                with open(full_path, "w", encoding="utf-8") as f: f.write(str(content))
        else:
            with open(os.path.join(templates_dir, "index.html"), "w", encoding="utf-8") as f:
                f.write(str(raw_html).strip())

        return jsonify({"success": True})
    except Exception as e:
        print(f"AI Error: {e}")
        return jsonify({"success": False, "error": str(e)})

# --- RUN/STOP (SAFE TEMP LOGGING) ---

@app.route('/run_app/<project>')
def run_app(project):
    try:
        global current_user_process
        
        if current_user_process:
            try: 
                os.kill(current_user_process.pid, signal.SIGTERM)
                current_user_process.wait(timeout=2)
            except: pass

        kill_process_on_port(USER_APP_PORT)
        
        path = get_project_dir(project)
        if not os.path.exists(os.path.join(path, "app.py")): 
            return jsonify({"success": False, "error": "app.py not found"})
        
        # Prepare Environment
        env = os.environ.copy()
        env['PORT'] = str(USER_APP_PORT)
        for k in ['WERKZEUG_SERVER_FD', 'WERKZEUG_RUN_MAIN']:
            if k in env: del env[k]

        # USE TEMP FILE FOR LOGGING (Prevents Permissions Errors)
        log_file = tempfile.TemporaryFile(mode='w+')
        
        current_user_process = subprocess.Popen(
            [sys.executable, "app.py"], 
            cwd=path, 
            env=env,
            stdout=log_file,
            stderr=log_file
        )
        
        time.sleep(2)
        
        if current_user_process.poll() is not None:
            # It died. Read the temp file.
            log_file.seek(0)
            err = log_file.read()
            return jsonify({"success": False, "error": f"Startup Failed:\n{err}"})

        return jsonify({"success": True, "url": "/live/"})

    except Exception as e:
        err_msg = traceback.format_exc()
        print(f"‚ùå INTERNAL ERROR: {err_msg}")
        return jsonify({"success": False, "error": f"INTERNAL BUILDER ERROR:\n{err_msg}"})

@app.route('/stop_app')
def stop_app():
    global current_user_process
    if current_user_process:
        try: os.kill(current_user_process.pid, signal.SIGTERM)
        except: pass
    kill_process_on_port(USER_APP_PORT)
    return jsonify({"success": True})

# --- AZURE PROXY (NUCLEAR REWRITE) ---
@app.route('/live', defaults={'path': ''}, methods=['GET', 'POST', 'PUT', 'DELETE'])
@app.route('/live/', defaults={'path': ''}, methods=['GET', 'POST', 'PUT', 'DELETE'])
@app.route('/live/<path:path>', methods=['GET', 'POST', 'PUT', 'DELETE'])
def live_proxy(path):
    if not current_user_process: return "<h3>App is not running. Click 'Run Live App' first.</h3>"
    target_url = f"http://127.0.0.1:{USER_APP_PORT}/{path}"
    
    try:
        resp = requests.request(
            method=request.method, url=target_url, headers={k:v for k,v in request.headers if k.lower() != 'host'},
            data=request.get_data(), cookies=request.cookies, allow_redirects=False
        )
        excluded_headers = ['content-encoding', 'content-length', 'transfer-encoding', 'connection', 'location']
        headers = [(name, value) for (name, value) in resp.raw.headers.items() if name.lower() not in excluded_headers]
        
        if 'Location' in resp.headers:
            loc = resp.headers['Location']
            if loc.startswith('/'): headers.append(('Location', f'/live{loc}'))
            else: headers.append(('Location', loc))

        content = resp.content
        if 'text/html' in resp.headers.get('Content-Type', ''):
            try:
                text = content.decode('utf-8')
                if '<head>' in text: text = text.replace('<head>', '<head><base href="/live/">')
                text = re.sub(r'(src|href|action)="/(?!live/)', r'\1="/live/', text)
                content = text.encode('utf-8')
            except: pass

        return Response(content, resp.status_code, headers)
    except Exception as e: return f"<h3>Proxy Error</h3><p>{e}</p>"

# --- STATIC PREVIEW ROUTE ---
@app.route('/preview/<project>')
def preview_project(project):
    try:
        path = get_project_dir(project)
        index_path = os.path.join(path, "templates", "index.html")
        if os.path.exists(index_path):
            with open(index_path, "r", encoding="utf-8") as f: return f.read()
        return "<h1>No index.html found</h1>"
    except Exception as e: return f"Error: {e}"

# --- HISTORY/ASSETS ---
@app.route('/history/<project>')
def get_history(project):
    try:
        cleanup_old_backups(project)
        backup_folder = os.path.join(BACKUP_DIR, secure_filename(project))
        
        if not os.path.exists(backup_folder): 
            return jsonify({"history": []})
            
        backups = []
        # Sort by name (which includes timestamp) to show newest first
        files = sorted([f for f in os.listdir(backup_folder) if f.endswith('.zip')], reverse=True)
        
        for f in files:
            try:
                # Robust parsing: strictly look for "Timestamp__Name" pattern
                parts = f.split('__')
                if len(parts) >= 2:
                    is_starred = "_STARRED" in f
                    # Clean up the label for display
                    label = parts[1].replace('.zip', '').replace('_', ' ').replace(' STARRED', '')
                    
                    # Format timestamp nicely (YYYYMMDD_HHMMSS -> YYYY-MM-DD HH:MM)
                    ts_raw = parts[0]
                    if len(ts_raw) == 15:
                        dt = datetime.datetime.strptime(ts_raw, "%Y%m%d_%H%M%S")
                        nice_time = dt.strftime("%b %d, %H:%M")
                        label = f"{nice_time} - {label}"

                    backups.append({"file": f, "label": label, "starred": is_starred})
            except:
                # If a file is malformed, just skip it. Don't break the app.
                continue
                
        return jsonify({"history": backups})
    except Exception as e:
        print(f"History Error: {e}")
        return jsonify({"history": []})
@app.route('/restore_project', methods=['POST'])
def restore_project():
    data = request.json; project = data.get('project'); path = get_project_dir(project)
    backup_path = os.path.join(BACKUP_DIR, secure_filename(project), data.get('backup_file'))
    if os.path.exists(backup_path):
        create_backup(project, "Pre_Restore_Safety")
        shutil.rmtree(path); os.makedirs(path); shutil.unpack_archive(backup_path, path)
        ensure_aux_files(path, project)
        return jsonify({"success": True})
    return jsonify({"success": False})

@app.route('/toggle_star', methods=['POST'])
def toggle_star():
    data = request.json; folder = os.path.join(BACKUP_DIR, secure_filename(data.get('project'))); old_path = os.path.join(folder, data.get('file'))
    if os.path.exists(old_path):
        new_name = data.get('file').replace("_STARRED", "") if "_STARRED" in data.get('file') else data.get('file').replace(".zip", "_STARRED.zip")
        os.rename(old_path, os.path.join(folder, new_name))
        return jsonify({"success": True})
    return jsonify({"success": False})

@app.route('/download_zip/<project>')
def download_zip(project):
    src = get_project_dir(project); ensure_aux_files(src, project)
    zip_path = shutil.make_archive(os.path.join(BACKUP_DIR, f"{project}_download"), 'zip', src)
    return send_file(zip_path, as_attachment=True, download_name=f"{project}_fullstack.zip")

@app.route('/upload_asset', methods=['POST'])
def upload_asset():
    if 'file' not in request.files: return jsonify({"success": False})
    file = request.files['file']; unique = f"{uuid.uuid4().hex[:6]}_{secure_filename(file.filename)}"
    file.save(os.path.join(app.config['UPLOAD_FOLDER'], unique))
    return jsonify({"success": True, "snippet": f'<img src="/static/uploads/{unique}" style="max-width:100%">'})

if __name__ == '__main__':
    print(f"--- Full Stack AI Builder running on http://127.0.0.1:5002 ---")
    app.run(debug=True, port=5002, use_reloader=False)